#!/usr/bin/env python3
"""
ğŸ“¡ Pump.fun Tracker - RPC + CoinGecko Edition

â€¢ Reads token list from CSV (generated by token fetcher)
â€¢ Uses only Solana RPC + CoinGecko for all 13 metrics
â€¢ No Moralis dependency during tracking
"""

import asyncio
import aiohttp
import csv
import json
import logging
import os
import sys
import time
from datetime import datetime, timedelta, timezone
from dataclasses import dataclass
from typing import Dict, List, Optional

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SOLANA_RPC_URL = "https://api.mainnet-beta.solana.com"
COINGECKO_URL = "https://api.coingecko.com/api/v3/simple/price?ids=solana&vs_currencies=usd"
JUPITER_PRICE_URL = "https://price.jup.ag/v4/price"  # Alternative price source

# Token list from fetcher script
TOKEN_LIST_CSV = "pump_tokens.csv"

# Pump.fun constants
PUMP_PROGRAM = "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P"
TARGET_SOL = 85
WINDOW = 10        # seconds
DURATION = 45 * 60  # seconds
TOTAL_SUPPLY = 1_000_000_000

CSV_HEADER = [
    "timestamp", "mint", "progress", "R", "A", "unique_buyers", "top3_pct",
    "lp_burn", "price_sol", "price_usd", "mcap_usd",
    "whale_flag", "buy_sell_delta", "buy_pressure", "sell_pressure", "bot_like"
]


def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()


def bonding_progress(sol_raised: float) -> float:
    """Calculate bonding curve progress based on SOL raised"""
    progress = (sol_raised / TARGET_SOL) * 100
    return min(100, max(0, progress))

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ dataclasses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


@dataclass
class IntervalState:
    start: datetime
    last_R: float = 0.0


@dataclass
class SamplerTask:
    mint: str
    name: str
    launch_time: datetime
    csv_path: str
    state: IntervalState
    remaining_duration: float


@dataclass
class Transaction:
    signature: str
    signer: str
    amount_sol: float
    timestamp: float
    is_buy: bool

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ main tracker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


class RPCTracker:
    def __init__(self) -> None:
        self.session: Optional[aiohttp.ClientSession] = None
        self.log = self._init_logger()
        self.active_tasks: Dict[str, SamplerTask] = {}
        self.sol_price_cache: Dict[str, float] = {}  # Cache SOL price
        self.active_tokens: List[str] = []  # Track active tokens

    def _init_logger(self):
        """Initialize logger"""
        os.makedirs("logs", exist_ok=True)
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s | %(levelname)s | %(message)s",
            handlers=[
                logging.FileHandler(
                    f"logs/rpc_tracker_{time.strftime('%Y%m%d')}.log"),
                logging.StreamHandler(sys.stdout)
            ]
        )
        return logging.getLogger("rpc-tracker")

    async def run(self) -> None:
        """Main runner - load tokens from CSV and start tracking"""
        async with aiohttp.ClientSession() as sess:
            self.session = sess

            # Test connections
            await self._test_connections()

            # Load tokens from CSV
            tokens = self._load_tokens_from_csv()

            if not tokens:
                self.log.error(
                    "âŒ No tokens loaded from CSV. Run token fetcher first!")
                return

            # Start tracking all tokens
            await self._start_tracking_tokens(tokens)

            # Monitor until all done
            await asyncio.gather(self._monitor_tasks(), self._heartbeat())

    async def _test_connections(self):
        """Test RPC and CoinGecko connections"""
        # Test Solana RPC
        rpc_payload = {"jsonrpc": "2.0", "id": 1, "method": "getHealth"}
        try:
            async with self.session.post(SOLANA_RPC_URL, json=rpc_payload) as response:
                if response.status == 200:
                    self.log.info("âœ… Solana RPC connection successful!")
                else:
                    raise RuntimeError(f"RPC HTTP {response.status}")
        except Exception as e:
            self.log.error(f"âŒ Solana RPC connection failed: {e}")
            raise

        # Test CoinGecko
        try:
            async with self.session.get(COINGECKO_URL) as response:
                if response.status == 200:
                    data = await response.json()
                    sol_price = data["solana"]["usd"]
                    self.log.info(
                        f"âœ… CoinGecko connection successful! SOL price: ${sol_price}")
                else:
                    raise RuntimeError(f"CoinGecko HTTP {response.status}")
        except Exception as e:
            self.log.error(f"âŒ CoinGecko connection failed: {e}")
            raise

    def _load_tokens_from_csv(self) -> List[Dict]:
        """Load tokens from CSV file"""
        if not os.path.exists(TOKEN_LIST_CSV):
            self.log.error(f"âŒ Token CSV file not found: {TOKEN_LIST_CSV}")
            self.log.error("   Run the token fetcher script first!")
            return []

        tokens = []
        trackable_tokens = []

        try:
            with open(TOKEN_LIST_CSV, "r", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    tokens.append(row)
                    if row.get("trackable", "").lower() == "true":
                        trackable_tokens.append(row)

            self.log.info(f"ğŸ“„ Loaded {len(tokens)} tokens from CSV")
            self.log.info(f"ğŸ¯ {len(trackable_tokens)} tokens are trackable")

            return trackable_tokens

        except Exception as e:
            self.log.error(f"Error loading CSV: {e}")
            return []

    async def _start_tracking_tokens(self, tokens: List[Dict]):
        """Start tracking all tokens from the list"""
        self.log.info(f"ğŸš€ Starting tracking for {len(tokens)} tokens...")

        active_count = 0

        for token in tokens:
            try:
                mint = token["tokenAddress"]
                name = token.get("name", "Unknown")
                created_at = datetime.fromisoformat(
                    token["createdAt"].replace("Z", "+00:00"))
                age_minutes = float(token.get("age_minutes", 0))

                # Calculate remaining tracking time
                remaining_minutes = 45 - age_minutes
                if remaining_minutes <= 0:
                    self.log.warning(
                        f"âš ï¸  Skipping {name} ({mint[:8]}) - tracking period expired")
                    continue

                # CHECK ACTIVITY BEFORE STARTING TRACKING
                is_active = await self._check_token_activity(mint)
                if not is_active:
                    self.log.warning(
                        f"âš ï¸  Skipping {name} ({mint[:8]}) - no recent trading activity")
                    continue

                remaining_seconds = remaining_minutes * 60

                # Start tracking
                await self._start_sampler(mint, name, created_at, remaining_seconds)
                active_count += 1
                self.active_tokens.append(mint)  # Add to active tokens

                # Small delay to avoid overwhelming RPC
                await asyncio.sleep(1)

            except Exception as e:
                self.log.error(
                    f"Error starting tracker for {token.get('tokenAddress', 'unknown')}: {e}")

        self.log.info(
            f"âœ… Started tracking {active_count} active tokens out of {len(tokens)} total")

    async def _start_sampler(self, mint: str, name: str, launch_time: datetime, duration_seconds: float):
        """Start tracking a single token"""
        fname = f"{mint[:6]}_{launch_time.strftime('%Y%m%d_%H%M%S')}.csv"
        path = os.path.join("tracks", fname)
        os.makedirs("tracks", exist_ok=True)

        # Create CSV with header
        with open(path, "w", newline="") as f:
            csv.writer(f).writerow(CSV_HEADER)

        task = SamplerTask(
            mint=mint,
            name=name,
            launch_time=launch_time,
            csv_path=path,
            state=IntervalState(start=datetime.now(timezone.utc)),
            remaining_duration=duration_seconds
        )

        self.active_tasks[mint] = task
        self.log.info(
            f"ğŸ“¡ Started tracking {name} ({mint[:8]}) for {duration_seconds/60:.1f}min â†’ {path}")

        # Start the sampling task
        asyncio.create_task(self._sampler(task))

    async def _sampler(self, t: SamplerTask):
        """Sample metrics every 10 seconds"""
        end_time = datetime.now(timezone.utc) + \
            timedelta(seconds=t.remaining_duration)
        sample_count = 0

        self.log.info(
            f"ğŸš€ Tracking {t.name} until {end_time.strftime('%H:%M:%S')}")

        while datetime.now(timezone.utc) < end_time:
            try:
                row = await self._collect_metrics(t)
                self._csv_append(t.csv_path, row)
                t.state.last_R = row["R"]
                sample_count += 1

                # Log every minute
                if sample_count % 6 == 0:
                    elapsed = (datetime.now(timezone.utc) - (end_time -
                               timedelta(seconds=t.remaining_duration))).total_seconds()
                    remaining = t.remaining_duration - elapsed

                    self.log.info(
                        f"ğŸ“Š {t.name} | {elapsed/60:.1f}min elapsed, {remaining/60:.1f}min remaining")
                    self.log.info(
                        f"   Progress: {row['progress']:.1f}% | Price: ${row['price_usd']:.8f}")
                    self.log.info(
                        f"   Buyers: {row['unique_buyers']} | Whale: {row['whale_flag']} | R: {row['R']:.4f}")

                    # Stop if fully migrated
                    if row['progress'] >= 100:
                        self.log.info(
                            f"ğŸ‰ {t.name} has migrated! Stopping tracking.")
                        break

            except Exception as e:
                self.log.error(f"Sample error for {t.mint[:8]}: {e}")
                default_row = self._default_row(t.mint)
                self._csv_append(t.csv_path, default_row)

            await asyncio.sleep(WINDOW)

        self.log.info(
            f"âœ… Completed tracking {t.name} ({sample_count} samples)")

        if t.mint in self.active_tasks:
            del self.active_tasks[t.mint]

    # â”€â”€ COLLECT METRICS USING ONLY RPC + COINGECKO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _collect_metrics(self, t: SamplerTask) -> Dict:
        """Collect metrics with enhanced debugging"""
        start = t.state.start
        end = start + timedelta(seconds=WINDOW)
        t.state.start = end

        try:
            # Get data
            sol_price_usd = await self._get_sol_price()
            token_price_data = await self._get_token_price_rpc(t.mint)
            transactions = await self._get_transactions_rpc(t.mint, start)
            bonding_data = await self._get_bonding_curve_state_rpc(t.mint)

            # ADD: Check for LP burns
            lp_burn = await self._check_lp_burn_rpc(t.mint, start)

            # Log what we found
            if len(transactions) > 0:
                self.log.info(
                    f"ğŸ¯ {t.name[:20]} | Found {len(transactions)} transactions!")
                for tx in transactions[:3]:
                    self.log.info(
                        f"   ğŸ“Š {tx.signer[:8]} | {tx.amount_sol:.4f} SOL | {'BUY' if tx.is_buy else 'SELL'}")

            # Process transactions
            metrics = self._process_transactions(transactions, sol_price_usd)

            # Calculate final metrics
            R = metrics["buy_volume"] - metrics["sell_volume"]
            A = R - t.state.last_R
            progress = bonding_data.get("progress", 0)
            price_usd = token_price_data.get("price_usd", 0)
            price_sol = price_usd / sol_price_usd if sol_price_usd > 0 else 0
            mcap_usd = price_usd * TOTAL_SUPPLY
            # Use end time
            whale_flag = await self._check_whale_activity_20s(t.mint, end)

            # Log final results
            if progress > 0 or len(transactions) > 0 or metrics["unique_buyers"] > 0:
                self.log.info(
                    f"âœ… {t.name[:20]} | Progress: {progress:.1f}% | R: {R:.4f} | Buyers: {metrics['unique_buyers']} | Price: ${price_usd:.8f}")

            return {
                "timestamp": now_iso(),
                "mint": t.mint,
                "progress": round(progress, 2),
                "R": round(R, 4),
                "A": round(A, 4),
                "unique_buyers": metrics["unique_buyers"],
                "top3_pct": round(metrics["top3_pct"], 2),
                "lp_burn": lp_burn,  # FIX: Use actual detection
                "price_sol": round(price_sol, 9),
                "price_usd": round(price_usd, 8),
                "mcap_usd": round(mcap_usd, 2),
                "whale_flag": whale_flag,
                "buy_sell_delta": round(R, 4),
                "buy_pressure": round(metrics["buy_volume"] / WINDOW, 5),
                "sell_pressure": round(metrics["sell_volume"] / WINDOW, 5),
                "bot_like": metrics["bot_like"]
            }

        except Exception as e:
            self.log.error(f"Error collecting metrics for {t.mint[:8]}: {e}")
            return self._default_row(t.mint)

    # â”€â”€ RPC DATA COLLECTION METHODS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async def _get_token_price_rpc(self, mint: str) -> Dict:
        """Get token price using WORKING sources only"""

        # 1. Try DexScreener (WORKING - returns $4.405e-06)
        try:
            url = f"https://api.dexscreener.com/latest/dex/tokens/{mint}"
            async with self.session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    pairs = data.get("pairs", [])
                    if pairs and len(pairs) > 0:
                        price_usd = float(pairs[0].get("priceUsd", 0))
                        if price_usd > 0:
                            self.log.debug(
                                f"âœ… DexScreener price for {mint[:8]}: ${price_usd}")
                            return {"price_usd": price_usd}
                    else:
                        self.log.debug(
                            f"DexScreener: No pairs found for {mint[:8]}")
        except Exception as e:
            self.log.debug(f"DexScreener error for {mint[:8]}: {e}")

        # 2. Fallback: Try Geckoterminal (alternative)
        try:
            url = f"https://api.geckoterminal.com/api/v2/simple/networks/solana/token_price/{mint}"
            async with self.session.get(url, timeout=5) as response:
                if response.status == 200:
                    data = await response.json()
                    token_prices = data.get("data", {}).get(
                        "attributes", {}).get("token_prices", {})
                    price_usd = float(token_prices.get(mint, 0))
                    if price_usd > 0:
                        self.log.debug(
                            f"âœ… Geckoterminal price for {mint[:8]}: ${price_usd}")
                        return {"price_usd": price_usd}
        except Exception as e:
            self.log.debug(f"Geckoterminal error for {mint[:8]}: {e}")

        # 3. If no price found, try to calculate from recent trades
        try:
            recent_trades = await self._get_recent_pump_trades(mint)
            if recent_trades:
                # Calculate average price from recent trades
                avg_price = sum(trade.get("price_usd", 0)
                                for trade in recent_trades) / len(recent_trades)
                if avg_price > 0:
                    self.log.debug(
                        f"âœ… Calculated price for {mint[:8]}: ${avg_price}")
                    return {"price_usd": avg_price}
        except Exception as e:
            self.log.debug(f"Trade calculation error for {mint[:8]}: {e}")

        self.log.warning(f"âŒ No price data found for {mint[:8]}")
        return {"price_usd": 0.0}

    async def _get_bonding_curve_state_rpc(self, mint: str) -> Dict:
        """Calculate progress from ALL transaction history"""
        try:
            # Get more signatures to calculate total progress
            all_signatures = await self._get_signatures_for_mint_all(mint)
            self.log.debug(
                f"Analyzing {len(all_signatures)} signatures for progress calculation")

            total_buy_volume = 0.0
            total_sell_volume = 0.0
            buy_count = 0
            sell_count = 0

            # Process ALL transactions to get total activity
            for signature in all_signatures:
                tx_data = await self._get_transaction_details(signature, mint)
                if tx_data:
                    if tx_data.is_buy:
                        total_buy_volume += tx_data.amount_sol
                        buy_count += 1
                    else:
                        total_sell_volume += tx_data.amount_sol
                        sell_count += 1

            # Calculate progress (pump.fun bonds at ~85 SOL)
            net_volume = total_buy_volume - total_sell_volume
            progress = min(100, (net_volume / 85) * 100)

            self.log.info(
                f"ğŸ“Š {mint[:8]} Progress: {progress:.1f}% | Buy: {total_buy_volume:.3f} SOL | Sell: {total_sell_volume:.3f} SOL | Net: {net_volume:.3f}")

            return {
                "progress": max(0, progress),
                "total_buy_volume": total_buy_volume,
                "total_sell_volume": total_sell_volume,
                "buy_count": buy_count,
                "sell_count": sell_count
            }

        except Exception as e:
            self.log.debug(f"Bonding curve error for {mint[:8]}: {e}")
            return {"progress": 0.0}

    async def _get_all_signatures_for_mint(self, mint: str) -> List[str]:
        """Get signatures without timestamp filtering"""
        try:
            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getSignaturesForAddress",
                "params": [mint, {"limit": 50}]  # Get more signatures
            }

            async with self.session.post(SOLANA_RPC_URL, json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    signatures = data.get("result", [])
                    return [sig["signature"] for sig in signatures]

        except Exception as e:
            self.log.debug(f"Error getting signatures: {e}")

        return []

    async def _get_transactions_rpc(self, mint: str, since: datetime) -> List[Transaction]:
        """Get transactions WITHOUT strict timestamp filtering"""
        try:
            # Get ALL recent signatures (don't filter by timestamp yet)
            token_signatures = await self._get_signatures_for_mint_all(mint)
            self.log.debug(
                f"Found {len(token_signatures)} total signatures for {mint[:8]}")

            # Parse ALL recent transactions to find trading activity
            transactions = []
            for signature in token_signatures[:20]:  # Check more transactions
                tx_data = await self._get_transaction_details(signature, mint)
                if tx_data:
                    transactions.append(tx_data)
                    self.log.debug(
                        f"âœ… Valid transaction: {tx_data.signer[:8]} | {tx_data.amount_sol:.4f} SOL | Buy: {tx_data.is_buy}")

            # Filter by time AFTER parsing (if needed)
            if since:
                since_timestamp = int(since.timestamp())
                recent_transactions = [
                    tx for tx in transactions if tx.timestamp >= since_timestamp - 3600]  # 1 hour window
                self.log.debug(
                    f"After time filter: {len(recent_transactions)} transactions")
                return recent_transactions

            return transactions

        except Exception as e:
            self.log.debug(f"Error getting transactions for {mint[:8]}: {e}")
            return []

    async def _get_signatures_for_mint_all(self, mint: str) -> List[str]:
        """Get signatures without timestamp filtering"""
        try:
            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getSignaturesForAddress",
                "params": [mint, {"limit": 50}]  # Get more signatures
            }

            async with self.session.post(SOLANA_RPC_URL, json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    signatures = data.get("result", [])
                    return [sig["signature"] for sig in signatures]

        except Exception as e:
            self.log.debug(f"Error getting signatures: {e}")

        return []

    async def _get_signatures_for_mint_recent(self, mint: str, since: datetime) -> List[str]:
        """Get recent signatures for a token since a specific time"""
        try:
            since_timestamp = int(since.timestamp())

            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getSignaturesForAddress",
                "params": [
                    mint,
                    {
                        "limit": 20,
                        "until": None,
                        "before": None
                    }
                ]
            }

            async with self.session.post(SOLANA_RPC_URL, json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    signatures = data.get("result", [])

                    # Filter by timestamp
                    recent_sigs = []
                    for sig_info in signatures:
                        block_time = sig_info.get("blockTime", 0)
                        if block_time >= since_timestamp:
                            recent_sigs.append(sig_info["signature"])

                    return recent_sigs

        except Exception as e:
            self.log.debug(f"Error getting recent signatures: {e}")

        return []

    def _parse_pump_transaction(self, tx: Dict, signature: str, mint: str) -> Optional[Transaction]:
        """Parse transaction with the exact format from debug results"""
        try:
            meta = tx.get("meta", {})
            transaction = tx.get("transaction", {})
            message = transaction.get("message", {})

            # We know pump.fun is involved from debug results
            account_keys = message.get("accountKeys", [])
            pump_program_found = any(
                acc.get("pubkey") == PUMP_PROGRAM for acc in account_keys
            )

            # Only process pump.fun transactions
            if not pump_program_found:
                return None

            # Get balance changes (we saw [-0.006126, 1e-06, 0.0, 0.002039, 0.0])
            pre_balances = meta.get("preBalances", [])
            post_balances = meta.get("postBalances", [])

            if len(pre_balances) != len(post_balances) or len(pre_balances) == 0:
                return None

            # Find the main trader (account with biggest SOL change)
            max_change = 0
            trader_index = 0
            signer = account_keys[0].get("pubkey") if account_keys else ""

            for i in range(min(len(pre_balances), len(account_keys))):
                sol_change = abs(
                    (post_balances[i] - pre_balances[i]) / 1_000_000_000)
                if sol_change > max_change and sol_change > 0.001:  # Meaningful change
                    max_change = sol_change
                    trader_index = i
                    if i < len(account_keys):
                        signer = account_keys[i].get("pubkey", signer)

            # Calculate trade details
            if max_change == 0:
                return None

            sol_change_lamports = post_balances[trader_index] - \
                pre_balances[trader_index]
            sol_change = sol_change_lamports / 1_000_000_000

            # Determine trade direction
            is_buy = sol_change < 0  # SOL leaving = buy
            trade_amount = abs(sol_change)

            # Filter out tiny transactions
            if trade_amount < 0.001:
                return None

            return Transaction(
                signature=signature,
                signer=signer,
                amount_sol=trade_amount,
                timestamp=tx.get("blockTime", 0),
                is_buy=is_buy
            )

        except Exception as e:
            self.log.debug(f"Error parsing transaction {signature[:8]}: {e}")
            return None

    def _process_transactions(self, transactions: List[Transaction], sol_price: float) -> Dict:
        """Process transactions to calculate trading metrics"""
        buy_volume = 0.0
        sell_volume = 0.0
        buyers = {}
        buy_timestamps = []  # Only buy timestamps
        buy_volumes = []     # Only buy volumes

        for tx in transactions:
            if tx.is_buy:
                buy_volume += tx.amount_sol
                buyers[tx.signer] = buyers.get(tx.signer, 0) + tx.amount_sol
                buy_timestamps.append(tx.timestamp)  # Collect buy data
                buy_volumes.append(tx.amount_sol)
            else:
                sell_volume += tx.amount_sol

        # Calculate metrics
        unique_buyers = len(buyers)

        # Top 3 concentration
        if buy_volume > 0:
            top3_volumes = sorted(buyers.values(), reverse=True)[:3]
            top3_pct = (sum(top3_volumes) / buy_volume) * 100
        else:
            top3_pct = 0.0

        # Bot-like detection (only for buys)
        bot_like = self._detect_bot_activity(buy_timestamps, buy_volumes)

        return {
            "buy_volume": buy_volume,
            "sell_volume": sell_volume,
            "unique_buyers": unique_buyers,
            "top3_pct": top3_pct,
            "bot_like": bot_like
        }

    def _detect_bot_activity(self, timestamps: List[float], volumes: List[float]) -> bool:
        """Detect bot-like trading patterns: â‰¥4 sub-0.1 SOL buys within 0.2s"""
        if len(timestamps) < 4 or len(volumes) < 4:
            return False

        # Create pairs of (timestamp, volume) and sort by timestamp
        trades = list(zip(timestamps, volumes))
        trades.sort(key=lambda x: x[0])

        # Check sliding window of 4 consecutive trades
        for i in range(len(trades) - 3):
            window_trades = trades[i:i+4]

            # Check if all 4 trades are within 0.2 seconds
            time_span = window_trades[-1][0] - window_trades[0][0]
            if time_span <= 0.2:
                # Check if all 4 trades are small (< 0.1 SOL)
                small_trades = [vol for _, vol in window_trades if vol < 0.1]
                if len(small_trades) >= 4:
                    self.log.info(
                        f"ğŸ¤– Bot-like activity detected: 4 trades < 0.1 SOL within {time_span:.3f}s")
                    return True

        return False

    async def _check_whale_activity_20s(self, mint: str, current_time: datetime) -> bool:
        """Check for whale activity (>=1 SOL) in last 20 seconds"""
        twenty_sec_ago = current_time - timedelta(seconds=20)
        transactions = await self._get_transactions_rpc(mint, twenty_sec_ago)

        for tx in transactions:
            if tx.amount_sol >= 1.0:
                return True
        return False

    async def _check_lp_burn_rpc(self, mint: str, since: datetime) -> bool:
        """Check for LP burns using RPC"""
        try:
            # Get recent signatures for the token
            signatures = await self._get_signatures_for_mint_recent(mint, since)

            for signature in signatures:
                tx_data = await self._get_full_transaction(signature)
                if tx_data and self._has_burn_instruction(tx_data):
                    self.log.info(
                        f"ğŸ”¥ LP burn detected for {mint[:8]} in {signature[:8]}")
                    return True

        except Exception as e:
            self.log.debug(f"LP burn check error for {mint[:8]}: {e}")

        return False

    async def _get_full_transaction(self, signature: str) -> Optional[Dict]:
        """Get full transaction data for burn detection"""
        try:
            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getTransaction",
                "params": [
                    signature,
                    {
                        "encoding": "jsonParsed",
                        "maxSupportedTransactionVersion": 0,
                        "commitment": "confirmed"
                    }
                ]
            }

            async with self.session.post(SOLANA_RPC_URL, json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    return data.get("result")

        except Exception as e:
            self.log.debug(f"Error getting full transaction: {e}")

        return None

    def _has_burn_instruction(self, tx_data: Dict) -> bool:
        """Check if transaction contains burn instructions"""
        try:
            instructions = tx_data.get("transaction", {}).get(
                "message", {}).get("instructions", [])

            for instruction in instructions:
                # Check for burn instruction
                parsed = instruction.get("parsed", {})
                if parsed.get("type") == "burn":
                    return True

                # Check for raw burn instruction
                program_id = instruction.get("programId")
                if program_id == "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA":
                    data = instruction.get("data", "")
                    # Burn instruction data starts with specific bytes
                    if data.startswith("BJeTJKy"):  # Base58 encoded burn instruction
                        return True

        except Exception as e:
            self.log.debug(f"Error checking burn instruction: {e}")

        return False

    async def _get_sol_price(self) -> float:
        """Get SOL price with caching"""
        current_minute = int(time.time() / 60)  # Cache per minute

        if current_minute in self.sol_price_cache:
            return self.sol_price_cache[current_minute]

        try:
            async with self.session.get(COINGECKO_URL) as response:
                if response.status == 200:
                    data = await response.json()
                    price = data["solana"]["usd"]
                    self.sol_price_cache[current_minute] = price
                    return price
        except Exception as e:
            self.log.debug(f"CoinGecko error: {e}")

        return 200.0  # Fallback

    # â”€â”€ HELPER METHODS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _default_row(self, mint: str) -> Dict:
        """Default row when data collection fails"""
        return {h: 0 if h not in ["timestamp", "mint", "lp_burn", "whale_flag", "bot_like"]
                else (now_iso() if h == "timestamp" else (mint if h == "mint" else False))
                for h in CSV_HEADER}

    @staticmethod
    def _csv_append(path: str, row: Dict) -> None:
        """Append row to CSV"""
        with open(path, "a", newline="") as f:
            csv.writer(f).writerow([row[h] for h in CSV_HEADER])

    async def _monitor_tasks(self):
        """Monitor active tasks"""
        while self.active_tasks:
            await asyncio.sleep(60)
        self.log.info("âœ… All tracking completed!")

    async def _heartbeat(self):
        """Heartbeat logging"""
        while True:
            self.log.info(
                f"â° heartbeat | active samplers = {len(self.active_tasks)}")
            await asyncio.sleep(300)

    async def _check_token_activity(self, mint: str) -> bool:
        """Check if token has recent trading activity"""
        try:
            signatures = await self._get_signatures_for_mint_all(mint)

            if len(signatures) < 3:
                self.log.debug(
                    f"âŒ {mint[:8]} has only {len(signatures)} signatures - inactive")
                return False

            # Check if any recent transactions are pump.fun related
            pump_transactions = 0
            for sig in signatures[:10]:
                tx_data = await self._get_transaction_details(sig, mint)
                if tx_data:
                    pump_transactions += 1

            if pump_transactions == 0:
                self.log.debug(
                    f"âŒ {mint[:8]} has no pump.fun transactions - inactive")
                return False

            self.log.debug(
                f"âœ… {mint[:8]} has {pump_transactions} pump transactions - active")
            return True

        except Exception as e:
            self.log.debug(f"Activity check error for {mint[:8]}: {e}")
            return False

    async def _get_transaction_details(self, signature: str, mint: str) -> Optional[Transaction]:
        """Get transaction details and parse for pump.fun activity"""
        try:
            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getTransaction",
                "params": [
                    signature,
                    {
                        "encoding": "jsonParsed",
                        "maxSupportedTransactionVersion": 0
                    }
                ]
            }

            async with self.session.post(SOLANA_RPC_URL, json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    tx = data.get("result")

                    if tx and tx.get("meta", {}).get("err") is None:
                        return self._parse_pump_transaction(tx, signature, mint)

        except Exception as e:
            self.log.debug(f"Error getting transaction {signature[:8]}: {e}")

        return None

    async def monitor_migrations(self):
        """Monitor for token migrations to Raydium/Pump.swap"""
        while True:
            # Check active tokens for migration
            for token in self.active_tokens:
                migration = await self._check_migration(token)
                if migration:
                    self.log.info(f"ğŸš€ {token} migrated to {migration.dex}")

            await asyncio.sleep(30)  # Check every 30 seconds


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ bootstrap â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    try:
        asyncio.run(RPCTracker().run())
    except KeyboardInterrupt:
        print("\nâ¹ stopped by user")
